-- Enable necessary extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "postgis";

-- ============================================
-- PROFILES TABLE (User Management)
-- ============================================
CREATE TABLE profiles (
  id UUID REFERENCES auth.users(id) PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  full_name TEXT,
  role TEXT DEFAULT 'user' CHECK (role IN ('user', 'admin', 'owner')),
  preferences JSONB DEFAULT '{
    "dietary": [],
    "price_range": "$$",
    "cuisine_preferences": [],
    "language": "en"
  }'::jsonb,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ============================================
-- VENUES TABLE (Restaurants/Bars)
-- ============================================
CREATE TABLE venues (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  owner_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  
  -- Basic Information
  name TEXT NOT NULL,
  slug TEXT UNIQUE NOT NULL,
  description TEXT,
  short_description TEXT,
  
  -- Location
  address TEXT NOT NULL,
  city TEXT NOT NULL,
  state TEXT,
  country TEXT NOT NULL DEFAULT 'RW',
  postal_code TEXT,
  latitude DECIMAL(10, 8),
  longitude DECIMAL(11, 8),
  location GEOGRAPHY(POINT, 4326), -- PostGIS for spatial queries
  
  -- Contact
  phone TEXT,
  email TEXT,
  website TEXT,
  
  -- Media
  image_url TEXT,
  cover_image_url TEXT,
  logo_url TEXT,
  gallery JSONB DEFAULT '[]'::jsonb, -- Array of image URLs
  
  -- Business Details
  cuisine_types TEXT[], -- Array: ['Italian', 'Mediterranean']
  price_range TEXT DEFAULT '$$' CHECK (price_range IN ('$', '$$', '$$$', '$$$$')),
  
  -- Hours of Operation (JSONB for flexibility)
  hours JSONB DEFAULT '{
    "monday": {"open": "09:00", "close": "22:00", "closed": false},
    "tuesday": {"open": "09:00", "close": "22:00", "closed": false},
    "wednesday": {"open": "09:00", "close": "22:00", "closed": false},
    "thursday": {"open": "09:00", "close": "22:00", "closed": false},
    "friday": {"open": "09:00", "close": "23:00", "closed": false},
    "saturday": {"open": "10:00", "close": "23:00", "closed": false},
    "sunday": {"open": "10:00", "close": "22:00", "closed": false}
  }'::jsonb,
  
  -- Features
  features TEXT[], -- ['outdoor_seating', 'live_music', 'wifi', 'parking']
  amenities TEXT[], -- ['wheelchair_accessible', 'kids_menu', 'bar']
  
  -- Status
  is_published BOOLEAN DEFAULT false,
  is_verified BOOLEAN DEFAULT false,
  status TEXT DEFAULT 'active' CHECK (status IN ('active', 'inactive', 'pending')),
  
  -- AI-related (stored for caching/analytics, not for display)
  last_ai_update TIMESTAMP WITH TIME ZONE,
  ai_category_confidence DECIMAL(3, 2),
  
  -- Metadata
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Search optimization
  search_vector TSVECTOR
);

-- Indexes for performance
CREATE INDEX idx_venues_owner ON venues(owner_id);
CREATE INDEX idx_venues_slug ON venues(slug);
CREATE INDEX idx_venues_location ON venues USING GIST(location);
CREATE INDEX idx_venues_city ON venues(city);
CREATE INDEX idx_venues_cuisine ON venues USING GIN(cuisine_types);
CREATE INDEX idx_venues_published ON venues(is_published) WHERE is_published = true;
CREATE INDEX idx_venues_search ON venues USING GIN(search_vector);

-- Trigger to update search vector
CREATE OR REPLACE FUNCTION venues_search_vector_update() RETURNS TRIGGER AS $$
BEGIN
  NEW.search_vector := 
    setweight(to_tsvector('english', COALESCE(NEW.name, '')), 'A') ||
    setweight(to_tsvector('english', COALESCE(NEW.description, '')), 'B') ||
    setweight(to_tsvector('english', COALESCE(array_to_string(NEW.cuisine_types, ' '), '')), 'C');
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER venues_search_vector_trigger
  BEFORE INSERT OR UPDATE ON venues
  FOR EACH ROW EXECUTE FUNCTION venues_search_vector_update();

-- ============================================
-- MENU_CATEGORIES TABLE (Static Categories)
-- ============================================
CREATE TABLE menu_categories (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  venue_id UUID REFERENCES venues(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  description TEXT,
  display_order INTEGER DEFAULT 0,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_menu_categories_venue ON menu_categories(venue_id);

-- ============================================
-- MENU_ITEMS TABLE (Individual Dishes)
-- ============================================
CREATE TABLE menu_items (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  venue_id UUID REFERENCES venues(id) ON DELETE CASCADE,
  category_id UUID REFERENCES menu_categories(id) ON DELETE SET NULL,
  
  -- Basic Information
  name TEXT NOT NULL,
  description TEXT,
  short_description TEXT,
  
  -- Pricing
  price DECIMAL(10, 2),
  original_price DECIMAL(10, 2), -- For discounts
  currency TEXT DEFAULT 'RWF',
  
  -- Media
  image_url TEXT,
  images JSONB DEFAULT '[]'::jsonb, -- Multiple images
  
  -- Attributes
  ingredients TEXT[],
  allergens TEXT[], -- ['nuts', 'dairy', 'gluten', 'shellfish']
  dietary_tags TEXT[], -- ['vegetarian', 'vegan', 'gluten_free', 'halal']
  spice_level INTEGER CHECK (spice_level BETWEEN 0 AND 5),
  
  -- Availability
  is_available BOOLEAN DEFAULT true,
  is_seasonal BOOLEAN DEFAULT false,
  available_days TEXT[], -- ['monday', 'tuesday', ...]
  available_times JSONB, -- {"start": "11:00", "end": "14:00"}
  
  -- Nutrition (optional)
  calories INTEGER,
  nutrition_info JSONB, -- Detailed nutrition data
  
  -- Popularity
  view_count INTEGER DEFAULT 0,
  order_count INTEGER DEFAULT 0,
  rating DECIMAL(3, 2),
  
  -- AI-related
  last_ai_update TIMESTAMP WITH TIME ZONE,
  ai_generated_image BOOLEAN DEFAULT false,
  
  -- Metadata
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Search
  search_vector TSVECTOR
);

CREATE INDEX idx_menu_items_venue ON menu_items(venue_id);
CREATE INDEX idx_menu_items_category ON menu_items(category_id);
CREATE INDEX idx_menu_items_available ON menu_items(is_available) WHERE is_available = true;
CREATE INDEX idx_menu_items_dietary ON menu_items USING GIN(dietary_tags);
CREATE INDEX idx_menu_items_search ON menu_items USING GIN(search_vector);

-- Search vector trigger for menu items
CREATE OR REPLACE FUNCTION menu_items_search_vector_update() RETURNS TRIGGER AS $$
BEGIN
  NEW.search_vector := 
    setweight(to_tsvector('english', COALESCE(NEW.name, '')), 'A') ||
    setweight(to_tsvector('english', COALESCE(NEW.description, '')), 'B') ||
    setweight(to_tsvector('english', COALESCE(array_to_string(NEW.ingredients, ' '), '')), 'C');
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER menu_items_search_vector_trigger
  BEFORE INSERT OR UPDATE ON menu_items
  FOR EACH ROW EXECUTE FUNCTION menu_items_search_vector_update();

-- ============================================
-- REVIEWS TABLE (User Reviews)
-- ============================================
CREATE TABLE reviews (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  venue_id UUID REFERENCES venues(id) ON DELETE CASCADE,
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  
  rating INTEGER NOT NULL CHECK (rating BETWEEN 1 AND 5),
  title TEXT,
  content TEXT,
  images JSONB DEFAULT '[]'::jsonb,
  
  -- Ratings breakdown
  food_rating INTEGER CHECK (food_rating BETWEEN 1 AND 5),
  service_rating INTEGER CHECK (service_rating BETWEEN 1 AND 5),
  ambiance_rating INTEGER CHECK (ambiance_rating BETWEEN 1 AND 5),
  value_rating INTEGER CHECK (value_rating BETWEEN 1 AND 5),
  
  helpful_count INTEGER DEFAULT 0,
  verified_visit BOOLEAN DEFAULT false,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  UNIQUE(venue_id, user_id) -- One review per user per venue
);

CREATE INDEX idx_reviews_venue ON reviews(venue_id);
CREATE INDEX idx_reviews_user ON reviews(user_id);

-- ============================================
-- FAVORITES TABLE (User Saved Venues)
-- ============================================
CREATE TABLE favorites (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  venue_id UUID REFERENCES venues(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  UNIQUE(user_id, venue_id)
);

CREATE INDEX idx_favorites_user ON favorites(user_id);
CREATE INDEX idx_favorites_venue ON favorites(venue_id);

-- ============================================
-- AI_CACHE TABLE (Cache AI Responses)
-- ============================================
CREATE TABLE ai_cache (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  cache_key TEXT UNIQUE NOT NULL,
  cache_type TEXT NOT NULL, -- 'venue_category', 'item_category', 'image_gen'
  entity_id UUID NOT NULL,
  
  request_data JSONB NOT NULL,
  response_data JSONB NOT NULL,
  
  ai_provider TEXT, -- 'gemini', 'openai'
  model_used TEXT,
  tokens_used INTEGER,
  
  expires_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_ai_cache_key ON ai_cache(cache_key);
CREATE INDEX idx_ai_cache_entity ON ai_cache(entity_id);
CREATE INDEX idx_ai_cache_expires ON ai_cache(expires_at);

-- Auto-delete expired cache entries
CREATE OR REPLACE FUNCTION delete_expired_ai_cache() RETURNS void AS $$
BEGIN
  DELETE FROM ai_cache WHERE expires_at < NOW();
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- ANALYTICS TABLE (Track Usage)
-- ============================================
CREATE TABLE analytics (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  event_type TEXT NOT NULL, -- 'view', 'click', 'search', 'favorite'
  entity_type TEXT, -- 'venue', 'menu_item'
  entity_id UUID,
  user_id UUID REFERENCES profiles(id) ON DELETE SET NULL,
  
  metadata JSONB DEFAULT '{}'::jsonb,
  ip_address INET,
  user_agent TEXT,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_analytics_event ON analytics(event_type);
CREATE INDEX idx_analytics_entity ON analytics(entity_id);
CREATE INDEX idx_analytics_created ON analytics(created_at);

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Enable RLS on all tables
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE venues ENABLE ROW LEVEL SECURITY;
ALTER TABLE menu_categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE menu_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE reviews ENABLE ROW LEVEL SECURITY;
ALTER TABLE favorites ENABLE ROW LEVEL SECURITY;

-- Profiles: Users can only read/update their own profile
CREATE POLICY "Users can view their own profile" ON profiles
  FOR SELECT USING (auth.uid() = id);

CREATE POLICY "Users can update their own profile" ON profiles
  FOR UPDATE USING (auth.uid() = id);

-- Venues: Public read, owner write
CREATE POLICY "Anyone can view published venues" ON venues
  FOR SELECT USING (is_published = true OR owner_id = auth.uid());

CREATE POLICY "Owners can insert their venues" ON venues
  FOR INSERT WITH CHECK (owner_id = auth.uid());

CREATE POLICY "Owners can update their venues" ON venues
  FOR UPDATE USING (owner_id = auth.uid());

CREATE POLICY "Owners can delete their venues" ON venues
  FOR DELETE USING (owner_id = auth.uid());

-- Menu Items: Public read, owner write
CREATE POLICY "Anyone can view available menu items" ON menu_items
  FOR SELECT USING (
    is_available = true OR 
    EXISTS (SELECT 1 FROM venues WHERE venues.id = menu_items.venue_id AND venues.owner_id = auth.uid())
  );

CREATE POLICY "Venue owners can manage menu items" ON menu_items
  FOR ALL USING (
    EXISTS (SELECT 1 FROM venues WHERE venues.id = menu_items.venue_id AND venues.owner_id = auth.uid())
  );

-- Reviews: Users can manage their own reviews
CREATE POLICY "Anyone can view reviews" ON reviews
  FOR SELECT USING (true);

CREATE POLICY "Users can create reviews" ON reviews
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their reviews" ON reviews
  FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their reviews" ON reviews
  FOR DELETE USING (auth.uid() = user_id);

-- Favorites: Users manage their own favorites
CREATE POLICY "Users can manage their favorites" ON favorites
  FOR ALL USING (auth.uid() = user_id);

-- ============================================
-- FUNCTIONS & TRIGGERS
-- ============================================

-- Update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at() RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER profiles_updated_at BEFORE UPDATE ON profiles
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

CREATE TRIGGER venues_updated_at BEFORE UPDATE ON venues
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

CREATE TRIGGER menu_items_updated_at BEFORE UPDATE ON menu_items
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

CREATE TRIGGER reviews_updated_at BEFORE UPDATE ON reviews
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

-- Automatically create profile on user signup
CREATE OR REPLACE FUNCTION handle_new_user() RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO profiles (id, email, full_name)
  VALUES (
    NEW.id,
    NEW.email,
    NEW.raw_user_meta_data->>'full_name'
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION handle_new_user();

-- Update venue location from lat/lng
CREATE OR REPLACE FUNCTION update_venue_location() RETURNS TRIGGER AS $$
BEGIN
  IF NEW.latitude IS NOT NULL AND NEW.longitude IS NOT NULL THEN
    NEW.location = ST_SetSRID(ST_MakePoint(NEW.longitude, NEW.latitude), 4326)::geography;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER venue_location_trigger
  BEFORE INSERT OR UPDATE ON venues
  FOR EACH ROW EXECUTE FUNCTION update_venue_location();

-- ============================================
-- UTILITY FUNCTIONS
-- ============================================

-- Get nearby venues
CREATE OR REPLACE FUNCTION get_nearby_venues(
  user_lat DECIMAL,
  user_lng DECIMAL,
  radius_km DECIMAL DEFAULT 10,
  limit_count INTEGER DEFAULT 20
)
RETURNS TABLE (
  venue_id UUID,
  venue_name TEXT,
  distance_km DECIMAL
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    v.id,
    v.name,
    ROUND((ST_Distance(
      v.location,
      ST_SetSRID(ST_MakePoint(user_lng, user_lat), 4326)::geography
    ) / 1000)::DECIMAL, 2) AS distance
  FROM venues v
  WHERE 
    v.is_published = true
    AND ST_DWithin(
      v.location,
      ST_SetSRID(ST_MakePoint(user_lng, user_lat), 4326)::geography,
      radius_km * 1000
    )
  ORDER BY distance
  LIMIT limit_count;
END;
$$ LANGUAGE plpgsql;

-- Search venues
CREATE OR REPLACE FUNCTION search_venues(
  search_query TEXT,
  limit_count INTEGER DEFAULT 20
)
RETURNS TABLE (
  venue_id UUID,
  venue_name TEXT,
  relevance REAL
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    v.id,
    v.name,
    ts_rank(v.search_vector, plainto_tsquery('english', search_query)) AS rank
  FROM venues v
  WHERE 
    v.is_published = true
    AND v.search_vector @@ plainto_tsquery('english', search_query)
  ORDER BY rank DESC
  LIMIT limit_count;
END;
$$ LANGUAGE plpgsql;
